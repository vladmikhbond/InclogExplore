fpBerkovskyi	[["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder = undefined"],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,90,[],["","\r\n\r\n\r\n\r\nshow' shift Z = shift ++ \" z\"\r\n show' shift (T n l r) =\r\n shift ++ show n ++ \"\\n\" ++\r\n shift ++ show' \" \" l ++ \"\\n\" ++\r\n shift ++ show' \" \" r"]],[],[],[],[],[],[],[],[],[],[],[79,186,[0,79,[],["","()"]],[]],[],[80,187,[0,80,[],["","T n l r"]],[]],[88,186,[0,88,[],[""," "]],[]],[],[],[],[],[100,175,[0,91,[],["undefined","[]]"]],[]],[94,175,[0,92,[],[0,1,["","n"],["]","++"]]],[]],[],[],[96,175,[0,94,[],[0,2,[""," "],[""," "]]],[]],[],[],[],[],[],[],[],[],[],[],[],[],[],[98,175,[0,98,[],["","preOrder"]],[]],[106,175,[0,106,[],[""," l ++ "]],[]],[],[112,175,[0,112,[],["","preOrder r"]],[]],[],[],[],[],[68,229,[0,68,[],["","preOrder "]],[]],[77,229,[0,77,[],["","Z"]],[]],[0,78,[],[0,56,[""," = 0"],["\r\n\r\n\r\nshow' shift Z = shift ++ \" z\"\r\n show' shift (T n l r) =\r\n shift ++ show n ++ \"\\n\" ++\r\n shift ++ show' \" \" l ++ \"\\n\" ++\r\n shift ++ show' \" \" r",""]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = 0\r\npreOrder (T n l r) = [n] ++ preOrder l ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-16 поз.1: error:\r\n * Non type-variable argument in the constraint: Num [a]\r\n (Use FlexibleContexts to permit this)\r\n * When checking the inferred type\r\n preOrder :: forall a. Num [a] => Tree a -> [a]\r\n |\n4 | preOrder Z = 0\r\r\n | ^^^^^^^^^^^^^^^..."],[0,138,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-16 поз.1: error:\r\n * Non type-variable argument in the constraint: Num [a]\r\n (Use FlexibleContexts to permit this)\r\n * When checking the inferred type\r\n preOrder :: forall a. Num [a] => Tree a -> [a]\r\n |\n4 | preOrder Z = 0\r\r\n | ^^^^^^^^^^^^^^^...",""]],[],[],[],[0,81,[],[0,57,["","["],[]]],[0,83,[],[0,56,["","]"],[]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [0]\r\npreOrder (T n l r) = [n] ++ preOrder l ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\ncompiler exit code -1"],[0,140,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\ncompiler exit code -1",""]],[],[0,82,[],[1,57,["0","z"],[]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [z]\r\npreOrder (T n l r) = [n] ++ preOrder l ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-16 поз.15: error: Variable not in scope: z\r\n |\n4 | preOrder Z = [z]\r\r\n | ^"],[0,140,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-16 поз.15: error: Variable not in scope: z\r\n |\n4 | preOrder Z = [z]\r\r\n | ^",""]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [Z]\r\npreOrder (T n l r) = [n] ++ preOrder l ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-12 поз.8: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n In an equation for `t1': t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n |\n8 | t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:9:8: error:\r\n * No instance for (Num (Tree a2)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n In an equation for `t2':\r\n t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n |\n9 | t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:12:8: error:\r\n * Ambiguous type variable `a0' arising from a use of `/='\r\n prevents the constraint `(Eq a0)' from being solved.\r\n Probable fix: use a type annotation to specify what `a0' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\jpytttgo.10y.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:12:20: error:\r\n * No instance for (Num (Tree a0)) arising from the literal `1'\r\n * In the first argument of `T', namely `1'\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:13:8: error:\r\n * Ambiguous type variable `a1' arising from a use of `/='\r\n prevents the constraint `(Eq a1)' from being solved.\r\n Probable fix: use a type annotation to specify what `a1' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\jpytttgo.10y.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:13:24: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `0'\r\n * In the expression: 0\r\n In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:14:8: error:\r\n * Ambiguous type variable `a2' arising from a use of `/='\r\n prevents the constraint `(Eq a2)' from being solved."],[0,140,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-12 поз.8: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n In an equation for `t1': t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n |\n8 | t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:9:8: error:\r\n * No instance for (Num (Tree a2)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n In an equation for `t2':\r\n t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n |\n9 | t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:12:8: error:\r\n * Ambiguous type variable `a0' arising from a use of `/='\r\n prevents the constraint `(Eq a0)' from being solved.\r\n Probable fix: use a type annotation to specify what `a0' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\jpytttgo.10y.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:12:20: error:\r\n * No instance for (Num (Tree a0)) arising from the literal `1'\r\n * In the first argument of `T', namely `1'\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:13:8: error:\r\n * Ambiguous type variable `a1' arising from a use of `/='\r\n prevents the constraint `(Eq a1)' from being solved.\r\n Probable fix: use a type annotation to specify what `a1' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\jpytttgo.10y.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:13:24: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `0'\r\n * In the expression: 0\r\n In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\jpytttgo.10y.hs:14:8: error:\r\n * Ambiguous type variable `a2' arising from a use of `/='\r\n prevents the constraint `(Eq a2)' from being solved.",""]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,107,[],[0,33,["","preOrder l"],[]]],[0,117,[],[0,16,[""," ++ "],[14,3,["l ++ preOrder ",""],[]]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [Z]\r\npreOrder (T n l r) = preOrder l ++ [n] ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-12 поз.8: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n In an equation for `t1': t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n |\n8 | t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:9:8: error:\r\n * No instance for (Num (Tree a2)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n In an equation for `t2':\r\n t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n |\n9 | t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:12:8: error:\r\n * Ambiguous type variable `a0' arising from a use of `/='\r\n prevents the constraint `(Eq a0)' from being solved.\r\n Probable fix: use a type annotation to specify what `a0' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\ah3gl2ta.roq.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:12:20: error:\r\n * No instance for (Num (Tree a0)) arising from the literal `1'\r\n * In the first argument of `T', namely `1'\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:13:8: error:\r\n * Ambiguous type variable `a1' arising from a use of `/='\r\n prevents the constraint `(Eq a1)' from being solved.\r\n Probable fix: use a type annotation to specify what `a1' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\ah3gl2ta.roq.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:13:24: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `0'\r\n * In the expression: 0\r\n In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:14:8: error:\r\n * Ambiguous type variable `a2' arising from a use of `/='\r\n prevents the constraint `(Eq a2)' from being solved."],[0,140,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-12 поз.8: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n In an equation for `t1': t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n |\n8 | t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:9:8: error:\r\n * No instance for (Num (Tree a2)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n In an equation for `t2':\r\n t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n |\n9 | t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:12:8: error:\r\n * Ambiguous type variable `a0' arising from a use of `/='\r\n prevents the constraint `(Eq a0)' from being solved.\r\n Probable fix: use a type annotation to specify what `a0' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\ah3gl2ta.roq.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:12:20: error:\r\n * No instance for (Num (Tree a0)) arising from the literal `1'\r\n * In the first argument of `T', namely `1'\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:13:8: error:\r\n * Ambiguous type variable `a1' arising from a use of `/='\r\n prevents the constraint `(Eq a1)' from being solved.\r\n Probable fix: use a type annotation to specify what `a1' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\ah3gl2ta.roq.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:13:24: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `0'\r\n * In the expression: 0\r\n In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\ah3gl2ta.roq.hs:14:8: error:\r\n * Ambiguous type variable `a2' arising from a use of `/='\r\n prevents the constraint `(Eq a2)' from being solved.",""]],[],[],[],[],[],[],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [Z]\r\npreOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.22: error:\r\n * Couldn't match type `[Tree a]' with `Tree a'\r\n Expected type: [Tree a]\r\n Actual type: [[Tree a]]\r\n * In the expression: preOrder l : [n] ++ preOrder r\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\n * Relevant bindings include\r\n r :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:17)\r\n l :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:15)\r\n n :: Tree a (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:13)\r\n preOrder :: Tree (Tree a) -> [Tree a]\r\n (bound at C:\\temp\\cz4n5sxe.x4v.hs:4:1)\r\n |\n5 | preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\cz4n5sxe.x4v.hs:5:35: error:\r\n * Couldn't match type `Tree a' with `[Tree a]'\r\n Expected type: [[Tree a]]\r\n Actual type: [Tree a]\r\n * In the second argument of `(:)', namely `[n] ++ preOrder r'\r\n In the expression: preOrder l : [n] ++ preOrder r\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\n * Relevant bindings include\r\n r :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:17)\r\n l :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:15)\r\n n :: Tree a (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:13)\r\n preOrder :: Tree (Tree a) -> [Tree a]\r\n (bound at C:\\temp\\cz4n5sxe.x4v.hs:4:1)\r\n |\n5 | preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\r\n | ^^^^^^^^^^^^^^^^^"],[0,139,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.22: error:\r\n * Couldn't match type `[Tree a]' with `Tree a'\r\n Expected type: [Tree a]\r\n Actual type: [[Tree a]]\r\n * In the expression: preOrder l : [n] ++ preOrder r\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\n * Relevant bindings include\r\n r :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:17)\r\n l :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:15)\r\n n :: Tree a (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:13)\r\n preOrder :: Tree (Tree a) -> [Tree a]\r\n (bound at C:\\temp\\cz4n5sxe.x4v.hs:4:1)\r\n |\n5 | preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\cz4n5sxe.x4v.hs:5:35: error:\r\n * Couldn't match type `Tree a' with `[Tree a]'\r\n Expected type: [[Tree a]]\r\n Actual type: [Tree a]\r\n * In the second argument of `(:)', namely `[n] ++ preOrder r'\r\n In the expression: preOrder l : [n] ++ preOrder r\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\n * Relevant bindings include\r\n r :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:17)\r\n l :: Tree (Tree a) (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:15)\r\n n :: Tree a (bound at C:\\temp\\cz4n5sxe.x4v.hs:5:13)\r\n preOrder :: Tree (Tree a) -> [Tree a]\r\n (bound at C:\\temp\\cz4n5sxe.x4v.hs:4:1)\r\n |\n5 | preOrder (T n l r) = preOrder l : [n] ++ preOrder r\r\r\n | ^^^^^^^^^^^^^^^^^",""]],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [Z]\r\npreOrder (T n l r) = preOrder l : [n] : preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-16 поз.1: error:\r\n * Couldn't match type `Tree a0' with `[a]'\r\n Expected type: Tree a -> [[a]]\r\n Actual type: Tree a -> [Tree a0]\r\n * Relevant bindings include\r\n preOrder :: Tree a -> [[a]] (bound at C:\\temp\\o5q2tra4.xap.hs:4:1)\r\n |\n4 | preOrder Z = [Z]\r\r\n | ^^^^^^^^^^^^^^^^^...\r\n\r\nC:\\temp\\o5q2tra4.xap.hs:5:22: error:\r\n * Couldn't match type `[[a]]' with `Tree a0'\r\n Expected type: [Tree a0]\r\n Actual type: [[[a]]]\r\n * In the expression: preOrder l : [n] : preOrder r\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l : [n] : preOrder r\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\o5q2tra4.xap.hs:5:17)\r\n l :: Tree a (bound at C:\\temp\\o5q2tra4.xap.hs:5:15)\r\n n :: a (bound at C:\\temp\\o5q2tra4.xap.hs:5:13)\r\n preOrder :: Tree a -> [[a]] (bound at C:\\temp\\o5q2tra4.xap.hs:4:1)\r\n |\n5 | preOrder (T n l r) = preOrder l : [n] : preOrder r\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"],[0,138,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-16 поз.1: error:\r\n * Couldn't match type `Tree a0' with `[a]'\r\n Expected type: Tree a -> [[a]]\r\n Actual type: Tree a -> [Tree a0]\r\n * Relevant bindings include\r\n preOrder :: Tree a -> [[a]] (bound at C:\\temp\\o5q2tra4.xap.hs:4:1)\r\n |\n4 | preOrder Z = [Z]\r\r\n | ^^^^^^^^^^^^^^^^^...\r\n\r\nC:\\temp\\o5q2tra4.xap.hs:5:22: error:\r\n * Couldn't match type `[[a]]' with `Tree a0'\r\n Expected type: [Tree a0]\r\n Actual type: [[[a]]]\r\n * In the expression: preOrder l : [n] : preOrder r\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l : [n] : preOrder r\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\o5q2tra4.xap.hs:5:17)\r\n l :: Tree a (bound at C:\\temp\\o5q2tra4.xap.hs:5:15)\r\n n :: a (bound at C:\\temp\\o5q2tra4.xap.hs:5:13)\r\n preOrder :: Tree a -> [[a]] (bound at C:\\temp\\o5q2tra4.xap.hs:4:1)\r\n |\n5 | preOrder (T n l r) = preOrder l : [n] : preOrder r\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",""]],[0,118,[],[7,13,[1,5,[":","++"],[":","++"]],[]]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = [Z]\r\npreOrder (T n l r) = preOrder l ++ [n] ++ preOrder r\r\n@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-12 поз.8: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n In an equation for `t1': t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n |\n8 | t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:9:8: error:\r\n * No instance for (Num (Tree a2)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n In an equation for `t2':\r\n t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n |\n9 | t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:12:8: error:\r\n * Ambiguous type variable `a0' arising from a use of `/='\r\n prevents the constraint `(Eq a0)' from being solved.\r\n Probable fix: use a type annotation to specify what `a0' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\pvbaewsh.gf5.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:12:20: error:\r\n * No instance for (Num (Tree a0)) arising from the literal `1'\r\n * In the first argument of `T', namely `1'\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:13:8: error:\r\n * Ambiguous type variable `a1' arising from a use of `/='\r\n prevents the constraint `(Eq a1)' from being solved.\r\n Probable fix: use a type annotation to specify what `a1' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\pvbaewsh.gf5.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:13:24: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `0'\r\n * In the expression: 0\r\n In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:14:8: error:\r\n * Ambiguous type variable `a2' arising from a use of `/='\r\n prevents the constraint `(Eq a2)' from being solved."],[0,140,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-12 поз.8: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n In an equation for `t1': t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\n |\n8 | t1 = T 4 (T 2 (T 1 (T 0 Z Z) Z) Z) Z\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:9:8: error:\r\n * No instance for (Num (Tree a2)) arising from the literal `4'\r\n * In the first argument of `T', namely `4'\r\n In the expression: T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n In an equation for `t2':\r\n t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\n |\n9 | t2 = T 4 (T 2 (T 1 (T 0 Z Z) Z) (T 3 Z Z)) (T 5 Z Z)\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:12:8: error:\r\n * Ambiguous type variable `a0' arising from a use of `/='\r\n prevents the constraint `(Eq a0)' from being solved.\r\n Probable fix: use a type annotation to specify what `a0' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\pvbaewsh.gf5.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:12:20: error:\r\n * No instance for (Num (Tree a0)) arising from the literal `1'\r\n * In the first argument of `T', namely `1'\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:13:8: error:\r\n * Ambiguous type variable `a1' arising from a use of `/='\r\n prevents the constraint `(Eq a1)' from being solved.\r\n Probable fix: use a type annotation to specify what `a1' should be.\r\n These potential instances exist:\r\n instance Eq Ordering -- Defined in `GHC.Classes'\r\n instance Eq Integer\r\n -- Defined in `integer-gmp-1.0.3.0:GHC.Integer.Type'\r\n instance Eq a => Eq (Tree a)\r\n -- Defined at C:\\temp\\pvbaewsh.gf5.hs:3:15\r\n ...plus 23 others\r\n ...plus 7 instances involving out-of-scope types\r\n (use -fprint-potential-instances to see them all)\r\n * In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n In an equation for `test':\r\n test\r\n | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\n | preOrder t1 /= [0, 1, 2, 4] = error \"Wrong.\"\r\n | preOrder t2 /= [0, 1, 2, 3, ....] = error \"Wrong.\"\r\n | otherwise = \"OK\"\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:13:24: error:\r\n * No instance for (Num (Tree a1)) arising from the literal `0'\r\n * In the expression: 0\r\n In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^\r\n\r\nC:\\temp\\pvbaewsh.gf5.hs:14:8: error:\r\n * Ambiguous type variable `a2' arising from a use of `/='\r\n prevents the constraint `(Eq a2)' from being solved.",""]],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\npreOrder Z = []\r\npreOrder (T n l r) = preOrder l ++ [n] ++ preOrder r\r\n@#$OK"]]
fpVasylets	[["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\n\r\npreOrder = "],[0,70,[],[0,13,["","preOrder "],[]]],[0,79,[],[0,13,["",":: Tree a -> "],[]]],[0,92,[],[0,13,["","T"],[]]],[0,92,[],[1,13,["T",""],[]]],[0,92,[],[0,11,["","[a]"],[1,1,["=","(T"],["",")"]]]],[0,109,[],[0,1,["","v l r"],[""," = v : "]]],[0,122,[],["","preOrder l : p"]],[0,97,[],[0,39,["","\r\n"],["","reOrder r;"]]],[0,97,[],[0,51,["","preOrder Z = "],[]]],[0,106,[],[15,40,["Z = \r\npreOrder ",""],[]]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,106,[],[0,27,["","Z = []\r\npreOrder "],[1,12,[":","++"],[]]]],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder :: Tree a -> [a]\r\npreOrder Z = []\r\npreOrder (T v l r) = v : preOrder l ++ preOrder r;@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\uaqawqd1.rif.hs:14:35 in main:Main\nКод завершения 1"],[0,164,[],["@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\uaqawqd1.rif.hs:14:35 in main:Main\nКод завершения 1",""]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,135,[],[14,15,[4,4,["v : ",""],[1,1,["r",""],["er l","v"]]],[]]],[0,139,[],[1,16,[0,1,["","r"],["","er l ++ "]],[]]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder :: Tree a -> [a]\r\npreOrder Z = []\r\npreOrder (T v Z Z) = [v];\r\npreOrder (T v l r) = preOrder l ++ [v] ++ preOrder r;@#$OK"]]
fpBurtsev	[["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder = undefined"],[0,88,[],["ed",""]],[0,79,[],[0,1,["","tree "],[" undefin",""]]],[0,85,[],[""," "]],[0,86,[],["","[] : "]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,91,[],["","Z "]],[0,79,[],[4,10,["tree","Z"],[]]],[0,86,[],[": Z ",""]],[0,79,[],[0,7,["","xs "],[]]],[],[],[],[],[0,86,[],[2,1,["[]","xs"],[]]],[0,88,[],[0,1,["","\r\npreOrder"],[""," "]]],[0,99,[],[0,1,["","xs"],["","tree "]]],[0,107,[],["","= "]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,109,[],["","f1 (Node y z ll rr) = (f1 ll) ++ [(y,z)] ++ (f1 rr)"]],[0,109,[],[2,49,["f1","Pre"],[]]],[0,109,[],[3,49,[1,2,["P","p"],["","Order"]],[]]],[],[],[],[],[],[],[],[],[],[],[],[],[81,85,[0,78,[],[" xs",""]],[]],[],[],[0,96,[],[3,64,["xs ",""],[]]],[],[0,96,[],[4,60,[1,3,["t","T"],[""," "]],[]]],[0,101,[],[0,60,["","t"],[]]],[],[0,96,[],[6,60,[0,6,["","("],["",")"]],[]]],[],[],[],[],[],[],[],[0,117,[],[14,33,["Node y z ll rr",""],[]]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,98,[],[5,1,["ree t",""],[" = preOrder () = (f1 ll) ++ [(y,z)] ++ (f1 rr)",""]]],[0,97,[],[1,1,["T","t n l r "],[]]],[0,104,[],[1,1,[" ",""],[]]],[],[],[],[],[0,105,[],[""," = "]],[],[],[],[0,108,[],[""," "]],[],[],[],[],[],[],[],[],[0,108,[],[0,1,["","preOrder"],[""," "]]],[0,117,[],[0,1,["","l"],[""," "]]],[0,119,[],[0,1,["","++"],[]]],[0,83,[],[2,37,["xs","[]"],["","pr"]]],[0,124,[],["","eOrder n ++ "]],[0,136,[],["","preOrder "]],[0,145,[],["","r"]],[],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (t n l r) = preOrder l ++ preOrder n ++ preOrder r@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.11: error: Parse error in pattern: t\r\n |\n6 | preOrder (t n l r) = preOrder l ++ preOrder n ++ preOrder r\r\r\n | ^^^^^^^"],[0,146,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.11: error: Parse error in pattern: t\r\n |\n6 | preOrder (t n l r) = preOrder l ++ preOrder n ++ preOrder r\r\r\n | ^^^^^^^",""]],[],[],[],[],[],[],[0,97,[],[1,48,["t","T"],[]]],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = preOrder l ++ preOrder n ++ preOrder r"],[],[],[0,90,[],[0,56,["","\r\npre"],[]]],[0,90,[],[0,61,["","Order a = "],[]]],[0,100,[],[0,61,["","a"],[]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder a = a\r\npreOrder (T n l r) = preOrder l ++ preOrder n ++ preOrder r"],[],[],[],[],[],[],[],[0,138,[],[10,14,[0,10,["","["],["","]"]],[]]],[0,154,[],[0,10,["","["],["","]"]]],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder a = a\r\npreOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.14: error:\r\n * Couldn't match expected type `[a6]' with actual type `Tree a'\r\n * In the expression: a\r\n In an equation for `preOrder': preOrder a = a\r\n * Relevant bindings include\r\n a :: Tree a (bound at C:\\temp\\qmgdfqzy.ejv.hs:6:10)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\qmgdfqzy.ejv.hs:5:1)\r\n |\n6 | preOrder a = a\r\r\n | ^"],[0,166,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.14: error:\r\n * Couldn't match expected type `[a6]' with actual type `Tree a'\r\n * In the expression: a\r\n In an equation for `preOrder': preOrder a = a\r\n * Relevant bindings include\r\n a :: Tree a (bound at C:\\temp\\qmgdfqzy.ejv.hs:6:10)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\qmgdfqzy.ejv.hs:5:1)\r\n |\n6 | preOrder a = a\r\r\n | ^",""]],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.36: error:\r\n * Occurs check: cannot construct the infinite type: a6 ~ [a6]\r\n Expected type: [a6]\r\n Actual type: [[a6]]\r\n * In the second argument of `(++)', namely\r\n `[preOrder n] ++ [preOrder r]'\r\n In the expression: preOrder l ++ [preOrder n] ++ [preOrder r]\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]\r\n * Relevant bindings include\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\qdegiel3.iif.hs:5:1)\r\n |\n6 | preOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\qdegiel3.iif.hs:6:46: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the expression: preOrder n\r\n In the first argument of `(++)', namely `[preOrder n]'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\qdegiel3.iif.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\qdegiel3.iif.hs:6:15)\r\n n :: a (bound at C:\\temp\\qdegiel3.iif.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\qdegiel3.iif.hs:5:1)\r\n |\n6 | preOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]\r\r\n | ^"],[0,150,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.36: error:\r\n * Occurs check: cannot construct the infinite type: a6 ~ [a6]\r\n Expected type: [a6]\r\n Actual type: [[a6]]\r\n * In the second argument of `(++)', namely\r\n `[preOrder n] ++ [preOrder r]'\r\n In the expression: preOrder l ++ [preOrder n] ++ [preOrder r]\r\n In an equation for `preOrder':\r\n preOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]\r\n * Relevant bindings include\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\qdegiel3.iif.hs:5:1)\r\n |\n6 | preOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]\r\r\n | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nC:\\temp\\qdegiel3.iif.hs:6:46: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the expression: preOrder n\r\n In the first argument of `(++)', namely `[preOrder n]'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\qdegiel3.iif.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\qdegiel3.iif.hs:6:15)\r\n n :: a (bound at C:\\temp\\qdegiel3.iif.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\qdegiel3.iif.hs:5:1)\r\n |\n6 | preOrder (T n l r) = preOrder l ++ [preOrder n] ++ [preOrder r]\r\r\n | ^",""]],[],[],[],[],[],[],[],[],[0,122,[],[1,27,["[",""],[]]],[0,132,[],[6,10,[1,4,["]",""],["[",""]],["]",""]]],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = preOrder l ++ preOrder n ++ preOrder r@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.45: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the first argument of `(++)', namely `preOrder n'\r\n In the second argument of `(++)', namely `preOrder n ++ preOrder r'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\mib5yijc.tay.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\mib5yijc.tay.hs:6:15)\r\n n :: a (bound at C:\\temp\\mib5yijc.tay.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\mib5yijc.tay.hs:5:1)\r\n |\n6 | preOrder (T n l r) = preOrder l ++ preOrder n ++ preOrder r\r\r\n | ^"],[0,146,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.45: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the first argument of `(++)', namely `preOrder n'\r\n In the second argument of `(++)', namely `preOrder n ++ preOrder r'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\mib5yijc.tay.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\mib5yijc.tay.hs:6:15)\r\n n :: a (bound at C:\\temp\\mib5yijc.tay.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\mib5yijc.tay.hs:5:1)\r\n |\n6 | preOrder (T n l r) = preOrder l ++ preOrder n ++ preOrder r\r\r\n | ^",""]],[],[],[],[],[],[0,108,[],[0,38,["","("],[]]],[0,119,[],[4,24,[0,4,["",")"],["","("]],[]]],[0,135,[],[4,10,[0,4,["",")"],["","("]],[]]],[0,151,[],["",")"]],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = (preOrder l) ++ (preOrder n) ++ (preOrder r)@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.48: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the first argument of `(++)', namely `(preOrder n)'\r\n In the second argument of `(++)', namely\r\n `(preOrder n) ++ (preOrder r)'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\1h0asdgi.t43.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\1h0asdgi.t43.hs:6:15)\r\n n :: a (bound at C:\\temp\\1h0asdgi.t43.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\1h0asdgi.t43.hs:5:1)\r\n |\n6 | preOrder (T n l r) = (preOrder l) ++ (preOrder n) ++ (preOrder r)\r\r\n | ^"],[0,152,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.48: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the first argument of `(++)', namely `(preOrder n)'\r\n In the second argument of `(++)', namely\r\n `(preOrder n) ++ (preOrder r)'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\1h0asdgi.t43.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\1h0asdgi.t43.hs:6:15)\r\n n :: a (bound at C:\\temp\\1h0asdgi.t43.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\1h0asdgi.t43.hs:5:1)\r\n |\n6 | preOrder (T n l r) = (preOrder l) ++ (preOrder n) ++ (preOrder r)\r\r\n | ^",""]],[],[],[],[],[],[],[],[],[],[0,118,[],[15,19,[0,15,["","T "],[""," T"]],[]]],[0,154,[],[0,2,["","T "],[]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = (preOrder T l) ++ (preOrder T n) ++ (preOrder T r)@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.1: error:\r\n * Couldn't match type `Tree a15'\r\n with `a -> Tree a -> Tree a -> Tree a'\r\n Expected type: (a -> Tree a -> Tree a -> Tree a)\r\n -> Tree a15 -> [a16]\r\n Actual type: Tree a15 -> [a16]\r\n * Relevant bindings include\r\n preOrder :: (a -> Tree a -> Tree a -> Tree a) -> Tree a15 -> [a16]\r\n (bound at C:\\temp\\rroqsdux.kbn.hs:5:1)\r\n |\n5 | preOrder Z = []\r\r\n | ^^^^^^^^^^^^^^^^...\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:12:18: error:\r\n * Couldn't match expected type `a0\r\n -> Tree a0 -> Tree a0 -> Tree a0'\r\n with actual type `Tree a11'\r\n * Possible cause: `T' is applied to too many arguments\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:12:30: error:\r\n * Couldn't match expected type `Tree a5 -> [a6]'\r\n with actual type `[a12]'\r\n * In the second argument of `(/=)', namely `[1]'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:13:17: error:\r\n * Couldn't match expected type `a2\r\n -> Tree a2 -> Tree a2 -> Tree a2'\r\n with actual type `Tree a1'\r\n * In the first argument of `preOrder', namely `t1'\r\n In the first argument of `(/=)', namely `preOrder t1'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:13:23: error:\r\n * Couldn't match expected type `Tree a7 -> [a8]'\r\n with actual type `[a13]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:14:17: error:\r\n * Couldn't match expected type `a4\r\n -> Tree a4 -> Tree a4 -> Tree a4'\r\n with actual type `Tree a3'\r\n * In the first argument of `preOrder', namely `t2'\r\n In the first argument of `(/=)', namely `preOrder t2'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:14:23: error:\r\n * Couldn't match expected type `Tree a9 -> [a10]'\r\n with actual type `[a14]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 3, ....]'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^"],[0,158,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.1: error:\r\n * Couldn't match type `Tree a15'\r\n with `a -> Tree a -> Tree a -> Tree a'\r\n Expected type: (a -> Tree a -> Tree a -> Tree a)\r\n -> Tree a15 -> [a16]\r\n Actual type: Tree a15 -> [a16]\r\n * Relevant bindings include\r\n preOrder :: (a -> Tree a -> Tree a -> Tree a) -> Tree a15 -> [a16]\r\n (bound at C:\\temp\\rroqsdux.kbn.hs:5:1)\r\n |\n5 | preOrder Z = []\r\r\n | ^^^^^^^^^^^^^^^^...\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:12:18: error:\r\n * Couldn't match expected type `a0\r\n -> Tree a0 -> Tree a0 -> Tree a0'\r\n with actual type `Tree a11'\r\n * Possible cause: `T' is applied to too many arguments\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:12:30: error:\r\n * Couldn't match expected type `Tree a5 -> [a6]'\r\n with actual type `[a12]'\r\n * In the second argument of `(/=)', namely `[1]'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:13:17: error:\r\n * Couldn't match expected type `a2\r\n -> Tree a2 -> Tree a2 -> Tree a2'\r\n with actual type `Tree a1'\r\n * In the first argument of `preOrder', namely `t1'\r\n In the first argument of `(/=)', namely `preOrder t1'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:13:23: error:\r\n * Couldn't match expected type `Tree a7 -> [a8]'\r\n with actual type `[a13]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:14:17: error:\r\n * Couldn't match expected type `a4\r\n -> Tree a4 -> Tree a4 -> Tree a4'\r\n with actual type `Tree a3'\r\n * In the first argument of `preOrder', namely `t2'\r\n In the first argument of `(/=)', namely `preOrder t2'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\rroqsdux.kbn.hs:14:23: error:\r\n * Couldn't match expected type `Tree a9 -> [a10]'\r\n with actual type `[a14]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 3, ....]'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^",""]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,118,[],[2,38,["T ",""],[]]],[0,134,[],[2,16,["T ",""],[2,2,["T ",""],[]]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = (preOrder l) ++ (preOrder n) ++ (preOrder r)@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.48: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the first argument of `(++)', namely `(preOrder n)'\r\n In the second argument of `(++)', namely\r\n `(preOrder n) ++ (preOrder r)'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\tr4b5f0x.jt4.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\tr4b5f0x.jt4.hs:6:15)\r\n n :: a (bound at C:\\temp\\tr4b5f0x.jt4.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\tr4b5f0x.jt4.hs:5:1)\r\n |\n6 | preOrder (T n l r) = (preOrder l) ++ (preOrder n) ++ (preOrder r)\r\r\n | ^"],[0,152,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-14 поз.48: error:\r\n * Occurs check: cannot construct the infinite type: a ~ Tree a\r\n * In the first argument of `preOrder', namely `n'\r\n In the first argument of `(++)', namely `(preOrder n)'\r\n In the second argument of `(++)', namely\r\n `(preOrder n) ++ (preOrder r)'\r\n * Relevant bindings include\r\n r :: Tree a (bound at C:\\temp\\tr4b5f0x.jt4.hs:6:17)\r\n l :: Tree a (bound at C:\\temp\\tr4b5f0x.jt4.hs:6:15)\r\n n :: a (bound at C:\\temp\\tr4b5f0x.jt4.hs:6:13)\r\n preOrder :: Tree a -> [a6] (bound at C:\\temp\\tr4b5f0x.jt4.hs:5:1)\r\n |\n6 | preOrder (T n l r) = (preOrder l) ++ (preOrder n) ++ (preOrder r)\r\r\n | ^",""]],[],[],[0,150,[],[0,2,["","T "],[]]],[0,118,[],[15,21,[0,15,["","T "],[""," T"]],[]]],[],[0,99,[],[1,58,["n","l"],[]]],[0,101,[],[1,56,["l","n"],[]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T l n r) = (preOrder T l) ++ (preOrder T n) ++ (preOrder T r)@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.1: error:\r\n * Couldn't match type `Tree t'\r\n with `a -> Tree a -> Tree a -> Tree a'\r\n Expected type: (a -> Tree a -> Tree a -> Tree a) -> t -> [a12]\r\n Actual type: Tree t -> [a12]\r\n * Relevant bindings include\r\n preOrder :: (a -> Tree a -> Tree a -> Tree a) -> t -> [a12]\r\n (bound at C:\\temp\\pkga5d0s.asj.hs:5:1)\r\n |\n5 | preOrder Z = []\r\r\n | ^^^^^^^^^^^^^^^^...\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:12:18: error:\r\n * Couldn't match expected type `a0\r\n -> Tree a0 -> Tree a0 -> Tree a0'\r\n with actual type `Tree a8'\r\n * Possible cause: `T' is applied to too many arguments\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:12:30: error:\r\n * Couldn't match expected type `t0 -> [a5]' with actual type `[a9]'\r\n * In the second argument of `(/=)', namely `[1]'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:13:17: error:\r\n * Couldn't match expected type `a2\r\n -> Tree a2 -> Tree a2 -> Tree a2'\r\n with actual type `Tree a1'\r\n * In the first argument of `preOrder', namely `t1'\r\n In the first argument of `(/=)', namely `preOrder t1'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:13:23: error:\r\n * Couldn't match expected type `t1 -> [a6]'\r\n with actual type `[a10]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:14:17: error:\r\n * Couldn't match expected type `a4\r\n -> Tree a4 -> Tree a4 -> Tree a4'\r\n with actual type `Tree a3'\r\n * In the first argument of `preOrder', namely `t2'\r\n In the first argument of `(/=)', namely `preOrder t2'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:14:23: error:\r\n * Couldn't match expected type `t2 -> [a7]'\r\n with actual type `[a11]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 3, ....]'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^"],[0,158,[],["@#$ОШИБКИ КОМПИЛЯЦИИ:\r\nстр.-15 поз.1: error:\r\n * Couldn't match type `Tree t'\r\n with `a -> Tree a -> Tree a -> Tree a'\r\n Expected type: (a -> Tree a -> Tree a -> Tree a) -> t -> [a12]\r\n Actual type: Tree t -> [a12]\r\n * Relevant bindings include\r\n preOrder :: (a -> Tree a -> Tree a -> Tree a) -> t -> [a12]\r\n (bound at C:\\temp\\pkga5d0s.asj.hs:5:1)\r\n |\n5 | preOrder Z = []\r\r\n | ^^^^^^^^^^^^^^^^...\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:12:18: error:\r\n * Couldn't match expected type `a0\r\n -> Tree a0 -> Tree a0 -> Tree a0'\r\n with actual type `Tree a8'\r\n * Possible cause: `T' is applied to too many arguments\r\n In the first argument of `preOrder', namely `(T 1 Z Z)'\r\n In the first argument of `(/=)', namely `preOrder (T 1 Z Z)'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^^^^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:12:30: error:\r\n * Couldn't match expected type `t0 -> [a5]' with actual type `[a9]'\r\n * In the second argument of `(/=)', namely `[1]'\r\n In the expression: preOrder (T 1 Z Z) /= [1]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder (T 1 Z Z) /= [1]\r\n |\n12 | test | preOrder (T 1 Z Z) /= [1] = error \"Wrong.\"\r\r\n | ^^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:13:17: error:\r\n * Couldn't match expected type `a2\r\n -> Tree a2 -> Tree a2 -> Tree a2'\r\n with actual type `Tree a1'\r\n * In the first argument of `preOrder', namely `t1'\r\n In the first argument of `(/=)', namely `preOrder t1'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:13:23: error:\r\n * Couldn't match expected type `t1 -> [a6]'\r\n with actual type `[a10]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 4]'\r\n In the expression: preOrder t1 /= [0, 1, 2, 4]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t1 /= [0, 1, 2, 4]\r\n |\n13 | | preOrder t1 /= [0,1,2,4] = error \"Wrong.\"\r\r\n | ^^^^^^^^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:14:17: error:\r\n * Couldn't match expected type `a4\r\n -> Tree a4 -> Tree a4 -> Tree a4'\r\n with actual type `Tree a3'\r\n * In the first argument of `preOrder', namely `t2'\r\n In the first argument of `(/=)', namely `preOrder t2'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^\r\n\r\nC:\\temp\\pkga5d0s.asj.hs:14:23: error:\r\n * Couldn't match expected type `t2 -> [a7]'\r\n with actual type `[a11]'\r\n * In the second argument of `(/=)', namely `[0, 1, 2, 3, ....]'\r\n In the expression: preOrder t2 /= [0, 1, 2, 3, ....]\r\n In a stmt of a pattern guard for\r\n an equation for `test':\r\n preOrder t2 /= [0, 1, 2, 3, ....]\r\n |\n14 | | preOrder t2 /= [0,1,2,3,4,5] = error \"Wrong.\"\r\r\n | ^^^^^^^^^^^^^",""]],[0,99,[],[3,56,[0,1,["","n "],[" n",""]],[]]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,73,[],[7,10,[1,5,["O","o"],["Z","Nil"]],[10,8,[1,6,["O","o"],[1,1,["T","Node"],["n","a"]]],[5,5,[1,3,["(",""],["O","o"]],[13,5,[4,4,[2,1,["T ",""],[")",""]],[1,3,["(","[a] ++ "],["O","o"]]],[10,1,["T n) ++ (p",""],["eOrder T r)",""]]]]]]],[0,73,[],[1,70,["o","O"],[]]],[0,79,[],[3,62,["Nil","Z"],[]]],[0,90,[],[1,51,["o","O"],[]]],[0,97,[],[4,41,["Node","T"],[]]],[0,111,[],[1,27,["o","O"],[]]],[0,132,[],[1,6,["o","O"],[]]],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T a l r) = preOrder l ++ [a] ++ preOrder r@#$OK"],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = []\r\npreOrder (T a l r) = preOrder l ++ [a] ++ preOrder r@#$OK"]]
fpTisheninova	[["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder = undefined"],[],[],[],[],[0,79,[],["= undefined",""]],[],[],[],[0,79,[],["","Z = [];\r\n"]],[0,88,[],["","preOrder "]],[0,97,[],["","(T a l r)"]],[0,106,[],[""," = "]],[0,109,[],["","[a]"]],[0,109,[],[1,1,["[",""],["]",":"]]],[0,111,[],["","(preOrder)"]],[0,120,[],[0,1,[""," l"],["","+"]]],[0,124,[],["","+"]],[0,125,[],["","(preOrder)"]],[0,134,[],[0,1,[""," r"],[]]],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = [];\r\npreOrder (T a l r) = a:(preOrder l)++(preOrder r)@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\0bceomqo.jkj.hs:13:35 in main:Main\nКод завершения 1"],[0,137,[],["@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\0bceomqo.jkj.hs:13:35 in main:Main\nКод завершения 1",""]],[],[],[0,109,[],[2,26,[0,1,["","["],[":","] ++ "]],[]]],[0,128,[],[2,12,[0,2,[""," "],[""," "]],[]]],[],[],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = [];\r\npreOrder (T a l r) = [a] ++ (preOrder l) ++ (preOrder r)@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\t4khhjex.ijj.hs:13:35 in main:Main\nКод завершения 1"],[0,144,[],["@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\t4khhjex.ijj.hs:13:35 in main:Main\nКод завершения 1",""]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = [];\r\npreOrder (T a l r) = [a] ++ (preOrder l) ++ (preOrder r)@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\ldub00br.4ya.hs:13:35 in main:Main\nКод завершения 1"],[0,144,[],["@#$ОШИБКА ВЫПОЛНЕНИЯ:\n Wrong.\nCallStack (from HasCallStack):\n error, called at C:\\temp\\ldub00br.4ya.hs:13:35 in main:Main\nКод завершения 1",""]],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[0,109,[],[7,28,["[a] ++ ",""],[]]],[0,125,[],[0,12,["","[a] ++ "],[]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder Z = [];\r\npreOrder (T a l r) = (preOrder l) ++ [a] ++ (preOrder r)@#$OK"]]
fpAliiev	[["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\n\r\npreOrder = undefined"],[],[],[],[],[2,88,["\r\n",""],[]],[],[0,88,["","\r\n"],[]],[],[2,88,["\r\n",""],[]],[],[],[],[],[0,66,[],[0,22,["","t = T 4 (T 2 (T 1 Z Z) (T 3 Z Z)) (T 5 Z Z)"],[]]],[],[],[],[],[],[],[0,123,[],["undefined",""]],[0,121,[],[0,2,[""," "],[]]],[0,121,[],[0,3,["","t"],[]]],[0,125,[],["","[t]"]],[0,128,[],[""," ++"]],[0,131,[],[""," "]],[],[],[0,121,[],[1,10,["t","()"],[]]],[0,122,[],[0,11,["","T n "],[]]],[0,126,[],[0,5,["","l r"],[1,5,["t",""],[]]]],[0,134,[],[0,5,["","n"],["","T "]]],[],[],["data Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\nt = T 4 (T 2 (T 1 Z Z) (T 3 Z Z)) (T 5 Z Z)\r\npreOrder (T n l r) = [n] ++ T ",""],[],[],["","data Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\nt = T 4 (T 2 (T 1 Z Z) (T 3 Z Z)) (T 5 Z Z)\r\npreOrder (T n l r) = [n] ++ T "],[],[],[],[],[],[],[],[],[],[0,140,[],["T ",""]],[0,140,[],["","preOrder( )"]],[],[],[0,148,[],["( )",""]],[0,140,[],[0,8,["","["],[]]],[0,149,[],["","] ++ preOrder"]],[0,154,[],[0,8,["","["],["","]"]]],[0,149,[],[0,14,[""," l"],[0,1,[""," r"],[]]]],[],[],[],[],[0,112,[],[0,56,["","\r\n"],["","\r\npreOrder (T n l r) = [n] ++ [preOrder l] ++ [preOrder r]"]]],[0,123,[],[9,96,[2,1,["(T","Z"],["n l r)",""]],[]]],[0,125,[],[1,95,[" ",""],[]]],[0,128,[],[33,42,["n] ++ [preOrder l] ++ [preOrder r",""],[1,16,["]",""],[]]]],[0,159,[],[11,16,[1,10,["[","("],["",")"]],[]]],[0,175,[],[1,10,["[","("],["]",")"]]],[],[],[],[0,66,["","\r\n"],[46,11,["t = T 4 (T 2 (T 1 Z Z) (T 3 Z Z)) (T 5 Z Z)\r\n",""],[2,2,["Z ",""],[9,2,["[]\r\npreOr","un"],[5,1,["r (T ","fi"],[18,1,[" l r) = [n] ++ (pr",""],[2,1,["Or",""],["er l) ++ (preOrder r)",""]]]]]]]],["","\r\ndata Tree a = Z | T a (Tree a) (Tree a)\r\n deriving (Eq, Show)\r\nt = T 4 (T 2 (T 1 Z Z) (T 3 Z Z)) (T 5 Z Z)\r\n\r\npreOrder Z = []\r\npreOrder (T n l r) = [n] ++ (preOrder l) ++ (preOrder r)"],[],[],[],[],[],[],[0,154,[],[3,32,["[n]",""],[]]],[0,154,[],[4,16,[" ++ ",""],[0,12,["","[] ++ "],[]]]],[]]

